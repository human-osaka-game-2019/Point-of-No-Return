#include "Character.h"

#include <vector>

#include "Mapchip.h"
<<<<<<< HEAD
/*
=======

void Hero::Notify()
{
	if (previousStatus.hp.value != status.hp.value)
	{
		Character::HpChangeNotify(status.hp);
	}

	if (previousStatus.mp.value != status.mp.value)
	{
		Character::MpChangeNotify(status.mp);
	}

	if (previousStatus.ip.value != status.ip.value)
	{
		Character::IpChangeNotify(status.ip);
	}
}

void Hero::Initialize()
{
	position =
	{
		CoordinateX(500.f),
		CoordinateY(500.f)
	};

	size =
	{
		Width(192.f),
		Height(192.f)
	};

	uv =
	{
		TextureU(0.0f),
		TextureV(0.0f)
	};

	texture_size =
	{
		Width(1.0f),
		Height(1.0f)
	};
>>>>>>> :sparkles:ObserverPatternの実装

	status =
	{
		HP(0,0),
		MP(0,0),
		IP(0,0),
		Attack(0,0),
		Defense(0,0),
		Speed(0,0),
		MagicAttack(0,0)
	};
<<<<<<< HEAD
*/
=======

	texture_name = TextureName("Player");
	degree = Degree(0);
	zoom = Zoom(1.0);
	is_reverse = IsReverse(false);
}

void Hero::Update()
{
	previous = position;

	previousStatus = status;

	if (dx.GetKeyState(DIK_D) == dx.ON)
	{
		position.x.value += 10.0f;
	}

	if (dx.GetKeyState(DIK_A) == dx.ON)
	{
		position.x.value -= 10.0f;
	}

	if (dx.GetKeyState(DIK_W) == dx.ON)
	{
		position.y.value -= 10.0f;
	}

	if (dx.GetKeyState(DIK_S) == dx.ON)
	{
		position.y.value += 10.0f;

	}
}

void Hero::CorrectCoordinate(Direction direction, const Vec2& blockPosition)
{
	switch (direction)
	{
	case Direction::Up:
		position.y.value = blockPosition.y.value - size.height.value;
		break;
	case Direction::Down:
		position.y.value = blockPosition.y.value + Mapchip::CHIP_SIZE;
		break;
	case Direction::Left:
		position.x.value = blockPosition.x.value - size.width.value;
		break;
	case Direction::Right:
		position.x.value = blockPosition.x.value + Mapchip::CHIP_SIZE;
		break;
	default:

		break;
	}
}

void Character::HpChangeNotify(const HP& hp)
{
	std::list<IHpObserver*>::iterator it;
	for (it = pHpList.begin(); it != pHpList.end(); it++)
	{
		(*it)->Update(hp);
	}
}

void Character::AddHpChangeObserver(IHpObserver* pIHpObserver)
{
	pHpList.push_back(pIHpObserver);
}

void Character::MpChangeNotify(const MP& mp)
{
	std::list<IMpObserver*>::iterator it;
	for (it = pMpList.begin(); it != pMpList.end(); it++)
	{
		(*it)->Update(mp);
	}
}

void Character::AddMpChangeObserver(IMpObserver* pMpObserver)
{
	pMpList.push_back(pMpObserver);
}

void Character::IpChangeNotify(const IP& ip)
{
	std::list<IIpObserver*>::iterator it;
	for (it = pIpList.begin(); it != pIpList.end(); it++)
	{
		(*it)->Update(ip);
	}
}

void Character::AddIpChangeObserver(IIpObserver* pIIpObserver)
{
	pIpList.push_back(pIIpObserver);
}
>>>>>>> :sparkles:ObserverPatternの実装
