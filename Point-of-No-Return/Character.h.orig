#ifndef CHARCTER_H_
#define CHARCTER_H_

#include "Object.h"
<<<<<<< HEAD
#include "Gravity.h"
=======
#include "../Point-of-No-Return/Observer/IObserver.h"
#include <list>
>>>>>>> :sparkles:ObserverPatternの実装

/**
 * @brief 方向
 */
enum class Direction
{
	//! 上
	Up,
	//! 下
	Down,
	//! 右
	Right,
	//! 左
	Left
};

/**
 * @brief キャラクタークラス
 */
class Character : public Object
{
public:
	/**
	 * @brief コンストラクタ
	 * @param name キャラクターの名前
	 */
	explicit Character(const std::string& name) :name(name) {}

	/**
	 * @brief	座標を修正する
	 * @param	direction　　　座標修正する方向
	 * @param	blockPosition　当たっているブロックの座標
	 * @details	HitCheckの中で呼び出す
	 */
<<<<<<< HEAD
	virtual void CorrectCoordinate(Direction direction, const Position& blockPosition) {}

=======
	virtual void CorrectCoordinate(Direction direction, const Vec2& blockPosition) {};

	virtual void HpChangeNotify(const HP& hp);

	virtual void AddHpChangeObserver(IHpObserver* pObserver);

	virtual void MpChangeNotify(const MP& mp);

	virtual void AddMpChangeObserver(IMpObserver* pObserver);

	virtual void IpChangeNotify(const IP& ip);

	virtual void AddIpChangeObserver(IIpObserver* pObserver);

protected:

	//! 前の座標を保存する
	Vec2 previous =
	{
		CoordinateX(0),
		CoordinateY(0)
	};

	Status status =
	{
		HP(0,0),
		MP(0,0),
		IP(0,0),
		Attack(0,0),
		Defense(0,0),
		Speed(0,0),
		MagicAttack(0,0)
	};

	Parameter parameter =
	{
		Luck(0,0),
		Love(0,0),
		Time(0,0),
		Gold(0,0),
		Age(0,0)
	};

	// TODO: あとでprimitive型wrapします
	float gravity = 0;

	// ObserverList
	std::list<IHpObserver*> pHpList;
	std::list<IMpObserver*> pMpList;
	std::list<IIpObserver*> pIpList;

private:

	//! キャラクターの名前
	Name name = Name("None");

};



/**
 * @brief 主人公クラス
 * @details コピーコンストラクタと演算子オーバーロードの隠蔽
 */
class Hero : public Character
{
public:
>>>>>>> :sparkles:ObserverPatternの実装
	/**
	 * @brief	previousPositionを取得する
	 */
	inline const Position& GetPreviousPosition() const
	{
		return previousPosition;
	}

	/**
	 * @brief	offsetを取得する
	 */
	inline const Position& GetOffset() const
	{
		return offset;
	}

	/**
	 * @brief	previousOffsetを取得する
	 */
	inline const Position& GetPreviousOffset() const
	{
		return previousOffset;
	}

	/**
	 * @brief	Vectorを取得する
	 */
	inline const Vec2 GetVector() const
	{
		Position startPosition =
		{
			CoordinateX(previousPosition.x.value + previousOffset.x.value),
			CoordinateY(previousPosition.y.value + previousOffset.y.value)
		};

		Position endPosition =
		{
			CoordinateX(position.x.value + offset.x.value),
			CoordinateY(position.y.value + offset.y.value)
		};

		Vec2 vector =
		{
			startPosition,
			endPosition
		};

		Status status =
		{
			HP(0),
			MP(0),
			IP(0),
			Attack(0),
			Defense(0),
			Speed(0),
			MagicAttack(0)
		};

		Parameter parameter =
		{
			Luck(0),
			Love(0),
			Time(0),
			Gold(0),
			Age(0)
		};

		return vector;
	}

protected:

	//! 前の座標を保存する
	Position previousPosition =
	{
		CoordinateX(0),
		CoordinateY(0)
	};

<<<<<<< HEAD
	Position offset =
	{
		CoordinateX(0),
		CoordinateY(0)
	};
=======
	void Notify();

private:
>>>>>>> :sparkles:ObserverPatternの実装

	Position previousOffset =
	{
		CoordinateX(0),
		CoordinateY(0)
	};

<<<<<<< HEAD
	Gravity gravity{ &position };
=======
	//コピーコンストラクタと演算子オーバーロードの隠蔽
	Hero(const Hero&);
	Hero& operator=(const Hero&);
	Hero(const Hero&&);
	Hero& operator=(const Hero&&);

	Status previousStatus =
	{
		HP(0,0),
		MP(0,0),
		IP(0,0),
		Attack(0,0),
		Defense(0,0),
		Speed(0,0),
		MagicAttack(0,0)
	};
};
>>>>>>> :sparkles:ObserverPatternの実装

private:

	//! キャラクターの名前
	Name name = Name("None");
};


/**
 * @brief UIクラス
 */
class UI : public Object
{

};

/**
 * @brief NPCクラス
 */
class NPC : public Character
{

};

/**
 * @brief 敵クラス
 */
class Enemy : public Character
{

};

#endif // !CHARCTER_H_
